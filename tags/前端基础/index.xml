<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>前端基础 on MaZiYo's Blog</title><link>https://dmaziyo.github.io/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/</link><description>Recent content in 前端基础 on MaZiYo's Blog</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 13 Mar 2024 13:05:17 +0800</lastBuildDate><atom:link href="https://dmaziyo.github.io/tags/%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80/index.xml" rel="self" type="application/rss+xml"/><item><title>JS和CSS以及DOM加载顺序</title><link>https://dmaziyo.github.io/posts/browser-render/</link><pubDate>Wed, 13 Mar 2024 13:05:17 +0800</pubDate><guid>https://dmaziyo.github.io/posts/browser-render/</guid><description>JS对DOM的影响 验证方式: 思路1：在html 标签内容前后写上script，然后打上断点，观察浏览器什么时候出现内容 结果:当断点出现在中途的时候，DOM的解析也停止了 思路2：script采用外部引入的方式，并且卡死请求时间，观察DOM状态 结果：将script请求卡死后，浏览器只渲染出来了HelloWorld,而the world没有出来
结论:浏览器是线性加载文档的，当碰到JS脚本时，就会执行JS的内容，而后续内容得等JS脚本执行完成后再加载。
CSS对DOM的影响 验证方式:配置服务器提供接口返回css文件，并且在请求过程设置响应时间，在进行响应css文件的时候，同时使用js监听事件&amp;rsquo;DOMContentLoaded&amp;rsquo;，观察DOM和css之间的关系参考链接 结论:CSS文件不会阻塞DOM文件解析
CSS对JS的影响 验证方式:配置服务器提供接口返回css文件，并且在请求过程设置响应时间，在进行响应css文件的时候，设置两组进行对照，一组是在css前面执行js，一组是在css后面执行js。观察是否有影响。 结果：当css在script前面时，script被css阻塞了，无法执行 结果：当script在css前面时，script正常运行 结论:CSS文件会阻塞JS文件加载，而又因为js会阻塞DOM的加载，所以CSS会间接阻塞DOM的加载.
总结：所以会有约定俗成的把script放在body尾部，link标签放在head内部，而页面通过CDN引入第三方框架或库时，基本都是将其script标签放在link标签前面。</description></item><item><title>手写一个bind函数</title><link>https://dmaziyo.github.io/posts/mybind/</link><pubDate>Tue, 26 Dec 2023 18:39:34 +0800</pubDate><guid>https://dmaziyo.github.io/posts/mybind/</guid><description>背景: 今天面试面到了，说不能使用apply和call来实现，当时脑袋空空，就放弃了,西八
Function.prototype.myBind=function(self,...prePendArgs){ // 在目标this对象上将当前函数添加上去，并且调用它 let fn = Symbol(&amp;#39;fn&amp;#39;); self[fn] = this; return function(...args){ let finalArgs =[...prePendArgs,...args] return self[fn](finalArgs); } } let obj1 = { name: &amp;#39;1&amp;#39;, sayHi(target) { console.log(&amp;#39;hi&amp;#39;, target, this.name) } } obj1.sayHi() let obj2 = { name: &amp;#39;2&amp;#39; } let bindFn = obj1.sayHi.myBind(obj2,&amp;#39;默认小马&amp;#39;) bindFn() bindFn(&amp;#39;非小马&amp;#39;)</description></item></channel></rss>